{
  "version": 3,
  "sources": ["df.js", "../../src/utils/audioResampler.js", "../../src/worklets/deepfilter-worklet.source.js"],
  "sourcesContent": ["let wasm;\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n/**\n* Get DeepFilterNet frame size in samples.\n* @param {number} st\n* @returns {number}\n*/\nexport function df_get_frame_length(st) {\n    const ret = wasm.df_get_frame_length(st);\n    return ret >>> 0;\n}\n\nlet cachedFloat32Memory0 = null;\n\nfunction getFloat32Memory0() {\n    if (cachedFloat32Memory0 === null || cachedFloat32Memory0.byteLength === 0) {\n        cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* Processes a chunk of samples.\n*\n* Args:\n*     - df_state: Created via df_create()\n*     - input: Input buffer of length df_get_frame_length()\n*     - output: Output buffer of length df_get_frame_length()\n*\n* Returns:\n*     - Local SNR of the current frame.\n* @param {number} st\n* @param {Float32Array} input\n* @returns {Float32Array}\n*/\nexport function df_process_frame(st, input) {\n    const ptr0 = passArrayF32ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.df_process_frame(st, ptr0, len0);\n    return takeObject(ret);\n}\n\n/**\n* Set DeepFilterNet post filter beta. A beta of 0 disables the post filter.\n*\n* Args:\n*     - beta: Post filter attenuation. Suitable range between 0.05 and 0;\n* @param {number} st\n* @param {number} beta\n*/\nexport function df_set_post_filter_beta(st, beta) {\n    wasm.df_set_post_filter_beta(st, beta);\n}\n\n/**\n* Set DeepFilterNet attenuation limit.\n*\n* Args:\n*     - lim_db: New attenuation limit in dB.\n* @param {number} st\n* @param {number} lim_db\n*/\nexport function df_set_atten_lim(st, lim_db) {\n    wasm.df_set_atten_lim(st, lim_db);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* Create a DeepFilterNet Model\n*\n* Args:\n*     - path: File path to a DeepFilterNet tar.gz onnx model\n*     - atten_lim: Attenuation limit in dB.\n*\n* Returns:\n*     - DF state doing the full processing: stft, DNN noise reduction, istft.\n* @param {Uint8Array} model_bytes\n* @param {number} atten_lim\n* @returns {number}\n*/\nexport function df_create(model_bytes, atten_lim) {\n    const ptr0 = passArray8ToWasm0(model_bytes, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.df_create(ptr0, len0, atten_lim);\n    return ret >>> 0;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n\nconst DFStateFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_dfstate_free(ptr >>> 0));\n/**\n*/\nexport class DFState {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        DFStateFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_dfstate_free(ptr);\n    }\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbg_crypto_566d7465cdbb6b7a = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbg_process_dc09a8c7d59982f6 = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_versions_d98c6400c6ca2bd8 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_node_caaf83d002149bd5 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbg_require_94a9da52636aacbf = function() { return handleError(function () {\n        const ret = module.require;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_msCrypto_0b84745e9245cdf6 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_randomFillSync_290977693942bf03 = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).randomFillSync(takeObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_getRandomValues_260cc23a41afad9a = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_newnoargs_e258087cd0daa0ea = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_63b92bc8671ed464 = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_9efabd6b6d2ce46d = function(arg0) {\n        const ret = new Float32Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_buffer_12d079cc21e14bdb = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_e9b4878cebadb3d3 = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_a47bac70306a19a7 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_subarray_a1f73cd4b5b42fe1 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_4a659d079a1650e0 = function(arg0, arg1, arg2) {\n        const ret = new Float32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_self_ce0dbfc45cf2f5be = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_window_c6fb939a7f436783 = function() { return handleError(function () {\n        const ret = window.window;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_d1e6af4856ba331b = function() { return handleError(function () {\n        const ret = globalThis.globalThis;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_global_207b558942527489 = function() { return handleError(function () {\n        const ret = global.global;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbg_call_27c0f87801dedf93 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_call_b3ca7c6051f9bec1 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, maybe_memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedFloat32Memory0 = null;\n    cachedUint8Memory0 = null;\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(input) {\n    if (wasm !== undefined) return wasm;\n\n    if (typeof input === 'undefined') {\n        input = new URL('df_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await input, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync }\nexport default __wbg_init;\n", "/**\n * High-Quality Audio Resampler\n * Implements anti-aliasing FIR filter + decimation for 48kHz \u2192 24kHz\n * Using Kaiser window for optimal stopband attenuation\n */\n\nexport class AudioResampler {\n  constructor() {\n    // Design parameters for 48kHz \u2192 24kHz (2:1 decimation)\n    this.decimationFactor = 2;\n    this.cutoffFreq = 0.4; // Well below Nyquist (0.5) for excellent anti-aliasing\n    this.filterOrder = 63; // Higher order = better stopband attenuation, minimal aliasing\n    this.beta = 7.5; // Kaiser window parameter (7.5 = better stopband rejection)\n\n    // Pre-compute FIR filter coefficients\n    this.filterCoeffs = this.designKaiserLowpass(\n      this.filterOrder,\n      this.cutoffFreq,\n      this.beta\n    );\n\n    // State buffer for FIR filtering (overlapping samples)\n    this.stateBuffer = new Float32Array(this.filterOrder);\n    this.statePos = 0;\n\n    console.log(\n      `[Resampler] Initialized: ${this.filterOrder}-tap Kaiser FIR, cutoff=${this.cutoffFreq}`\n    );\n  }\n\n  /**\n   * Design Kaiser-windowed lowpass FIR filter\n   * @param {number} order - Filter order (number of taps)\n   * @param {number} cutoff - Normalized cutoff frequency (0-1)\n   * @param {number} beta - Kaiser window beta parameter\n   * @returns {Float32Array} Filter coefficients\n   */\n  designKaiserLowpass(order, cutoff, beta) {\n    const M = order;\n    const coeffs = new Float32Array(M + 1);\n    const center = M / 2;\n\n    // Generate ideal sinc lowpass\n    for (let n = 0; n <= M; n++) {\n      if (n === center) {\n        coeffs[n] = 2 * cutoff; // sinc(0) = 1\n      } else {\n        const x = (n - center) * Math.PI;\n        coeffs[n] =\n          (Math.sin(2 * cutoff * x) / x) * this.kaiserWindow(n, M, beta);\n      }\n    }\n\n    // Normalize to unity gain at DC\n    const sum = coeffs.reduce((a, b) => a + b, 0);\n    for (let i = 0; i <= M; i++) {\n      coeffs[i] /= sum;\n    }\n\n    return coeffs;\n  }\n\n  /**\n   * Kaiser window function\n   * @param {number} n - Sample index\n   * @param {number} M - Window length - 1\n   * @param {number} beta - Shape parameter\n   * @returns {number} Window value\n   */\n  kaiserWindow(n, M, beta) {\n    const arg = beta * Math.sqrt(1 - Math.pow((2 * n) / M - 1, 2));\n    return this.besselI0(arg) / this.besselI0(beta);\n  }\n\n  /**\n   * Modified Bessel function of the first kind, order 0\n   * Used in Kaiser window calculation\n   * @param {number} x - Input value\n   * @returns {number} I0(x)\n   */\n  besselI0(x) {\n    let sum = 1.0;\n    let term = 1.0;\n    let m = 1;\n\n    // Series expansion (sufficient accuracy with 25 terms)\n    while (m < 25) {\n      term *= (x * x) / (4 * m * m);\n      sum += term;\n      m++;\n    }\n\n    return sum;\n  }\n\n  /**\n   * Apply FIR filter to input buffer\n   * @param {Float32Array} input - Input samples @ 48kHz\n   * @returns {Float32Array} Filtered samples @ 48kHz\n   */\n  applyFirFilter(input) {\n    const output = new Float32Array(input.length);\n    const M = this.filterOrder;\n\n    for (let n = 0; n < input.length; n++) {\n      let sum = 0;\n\n      // Convolve with FIR coefficients\n      for (let k = 0; k <= M; k++) {\n        const idx = n - k;\n        let sample;\n\n        if (idx >= 0) {\n          sample = input[idx];\n        } else {\n          // Use state buffer for past samples\n          const stateIdx =\n            (this.statePos + idx + this.stateBuffer.length) %\n            this.stateBuffer.length;\n          sample = this.stateBuffer[stateIdx];\n        }\n\n        sum += this.filterCoeffs[k] * sample;\n      }\n\n      output[n] = sum;\n    }\n\n    // Update state buffer with last M samples\n    for (let i = 0; i < Math.min(M, input.length); i++) {\n      this.stateBuffer[(this.statePos + i) % this.stateBuffer.length] =\n        input[input.length - M + i];\n    }\n    this.statePos =\n      (this.statePos + Math.min(M, input.length)) % this.stateBuffer.length;\n\n    return output;\n  }\n\n  /**\n   * Resample 48kHz \u2192 24kHz with anti-aliasing\n   * @param {Float32Array} input48k - Input samples @ 48kHz\n   * @returns {Float32Array} Output samples @ 24kHz\n   */\n  resample48to24(input48k) {\n    // Step 1: Apply anti-aliasing lowpass filter\n    const filtered = this.applyFirFilter(input48k);\n\n    // Step 2: Decimate by 2 (keep every other sample)\n    const outputLength = Math.floor(filtered.length / this.decimationFactor);\n    const output24k = new Float32Array(outputLength);\n\n    for (let i = 0; i < outputLength; i++) {\n      output24k[i] = filtered[i * this.decimationFactor];\n    }\n\n    return output24k;\n  }\n\n  /**\n   * Reset filter state (call when starting new stream)\n   */\n  reset() {\n    this.stateBuffer.fill(0);\n    this.statePos = 0;\n  }\n}\n\n/**\n * Audio Dynamic Processor\n * Implements:\n * - Adaptive gain normalization\n * - Soft limiter/compressor\n * - Peak detection\n */\nexport class AudioDynamicProcessor {\n  constructor() {\n    // SIMPLIFICADO: Solo normalizaci\u00F3n suave sin complejidad innecesaria\n    this.targetRMS = 0.58; // Target RMS m\u00E1s conservador\n    this.noiseGateThreshold = 0.0008; // Threshold muy bajo - solo silencio absoluto\n    this.smoothingFactor = 0.88; // MUY suave para eliminar pumping\n    this.previousGain = 1.0; // Empezar neutral\n  }\n\n  /**\n   * Calculate RMS (Root Mean Square) level of audio buffer\n   * @param {Float32Array} buffer\n   * @returns {number} RMS level (0-1)\n   */\n  calculateRMS(buffer) {\n    let sumSquares = 0;\n    for (let i = 0; i < buffer.length; i++) {\n      sumSquares += buffer[i] * buffer[i];\n    }\n    return Math.sqrt(sumSquares / buffer.length);\n  }\n\n  /**\n   * Calculate peak level of audio buffer\n   * @param {Float32Array} buffer\n   * @returns {number} Peak level (0-1)\n   */\n  calculatePeak(buffer) {\n    let peak = 0;\n    for (let i = 0; i < buffer.length; i++) {\n      const abs = Math.abs(buffer[i]);\n      if (abs > peak) peak = abs;\n    }\n    return peak;\n  }\n\n  /**\n   * Process audio buffer - SIMPLIFICADO para claridad\n   * @param {Float32Array} buffer - Input buffer\n   * @returns {Object} {processed: Float32Array, gainApplied: number, rms: number, peak: number, saturated: boolean}\n   */\n  process(buffer) {\n    // Calculate signal level\n    const rms = this.calculateRMS(buffer);\n    const peak = this.calculatePeak(buffer);\n\n    // Calcular gain target basado en RMS\n    let targetGain = 1.0;\n\n    if (rms < this.noiseGateThreshold) {\n      // Silencio absoluto - atenuar\n      targetGain = 0.25;\n    } else if (rms < 0.35) {\n      // Voz normal - normalizar\n      targetGain = Math.min(this.targetRMS / Math.max(rms, 0.008), 2.5);\n    } else if (rms < 0.55) {\n      // Voz moderada - ajuste suave\n      targetGain = Math.max(0.95, this.targetRMS / rms);\n    } else {\n      // Voz alta - reducir levemente\n      targetGain = 0.95;\n    }\n\n    // Prevenir clipping basado en peak\n    if (peak * targetGain > 0.96) {\n      targetGain = 0.93 / peak;\n    }\n\n    // Smoothing adaptivo: m\u00E1s r\u00E1pido para bajar gain, m\u00E1s lento para subir\n    // Esto evita distorsi\u00F3n cuando RMS baja s\u00FAbitamente\n    let smoothFactor = this.smoothingFactor;\n    if (targetGain < this.previousGain) {\n      // Bajar gain m\u00E1s r\u00E1pido (menos smoothing)\n      smoothFactor = 0.75;\n    }\n\n    const gain =\n      this.previousGain * smoothFactor + targetGain * (1 - smoothFactor);\n    this.previousGain = gain;\n\n    // Aplicar gain y limiter ultra-suave\n    const processed = new Float32Array(buffer.length);\n    let saturated = false;\n\n    for (let i = 0; i < buffer.length; i++) {\n      let sample = buffer[i] * gain;\n\n      // Soft limiter con knee MUY amplio (0.80 - 0.96)\n      const absValue = Math.abs(sample);\n      if (absValue > 0.8) {\n        const excess = absValue - 0.8;\n        const kneeWidth = 0.16; // Knee m\u00E1s amplio: 0.80 a 0.96\n\n        if (excess < kneeWidth) {\n          // Soft knee con curva ultra-suave\n          const ratio = excess / kneeWidth;\n          const curve = ratio * ratio * (3 - 2 * ratio); // S-curve\n          const compressed = 0.8 + excess * (1 - curve * 0.5); // Compresi\u00F3n m\u00E1s suave\n          sample = (sample / absValue) * Math.min(compressed, 0.96);\n        } else {\n          // Hard limit en 0.96\n          sample = (sample / absValue) * 0.96;\n          saturated = true;\n        }\n      }\n\n      processed[i] = sample;\n    }\n\n    return {\n      processed,\n      gainApplied: gain,\n      rms,\n      peak,\n      saturated,\n    };\n  }\n}\n\n/**\n * Circular Buffer for zero-copy audio buffering\n * Eliminates Array.splice() overhead and reduces GC pressure\n */\nexport class CircularBuffer {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.buffer = new Float32Array(capacity);\n    this.writePos = 0;\n    this.readPos = 0;\n    this.available = 0;\n  }\n\n  /**\n   * Push a single sample into the buffer\n   */\n  push(sample) {\n    this.buffer[this.writePos] = sample;\n    this.writePos = (this.writePos + 1) % this.capacity;\n    if (this.available < this.capacity) {\n      this.available++;\n    } else {\n      // Buffer full, advance read position\n      this.readPos = (this.readPos + 1) % this.capacity;\n    }\n  }\n\n  /**\n   * Get number of samples available to read\n   */\n  get length() {\n    return this.available;\n  }\n\n  /**\n   * Read N samples into a new Float32Array (non-destructive peek)\n   * Use this when you need to pass data to WASM or other APIs\n   */\n  peek(count) {\n    if (count > this.available) {\n      throw new Error(\n        `Cannot peek ${count} samples, only ${this.available} available`\n      );\n    }\n\n    const result = new Float32Array(count);\n    let readIdx = this.readPos;\n\n    for (let i = 0; i < count; i++) {\n      result[i] = this.buffer[readIdx];\n      readIdx = (readIdx + 1) % this.capacity;\n    }\n\n    return result;\n  }\n\n  /**\n   * Consume N samples (advance read position)\n   */\n  consume(count) {\n    if (count > this.available) {\n      throw new Error(\n        `Cannot consume ${count} samples, only ${this.available} available`\n      );\n    }\n\n    this.readPos = (this.readPos + count) % this.capacity;\n    this.available -= count;\n  }\n\n  /**\n   * Read and consume N samples in one operation\n   */\n  read(count) {\n    const data = this.peek(count);\n    this.consume(count);\n    return data;\n  }\n\n  /**\n   * Clear the buffer\n   */\n  clear() {\n    this.readPos = 0;\n    this.writePos = 0;\n    this.available = 0;\n  }\n}\n", "// DeepFilterNet Audio Worklet Source (para bundlear con esbuild)\n// Este archivo importa df.js y crea el processor\n\nimport init, {\n  df_create,\n  df_get_frame_length,\n  df_process_frame,\n  df_set_post_filter_beta,\n} from \"../../public/_worklets/df.js\";\n\nimport {\n  AudioResampler,\n  AudioDynamicProcessor,\n} from \"../../src/utils/audioResampler.js\";\n\n// Variable global para el WASM inicializado\nlet wasmInitialized = false;\nlet wasmInitPromise = null;\n\nclass DeepFilterProcessor extends AudioWorkletProcessor {\n  constructor(options) {\n    super();\n\n    this.sampleRate = 48000;\n    this.initialized = false;\n    this.dfState = null;\n    this.frameLength = 0;\n\n    // Input buffer for accumulating samples\n    this.inputBuffer = [];\n\n    // High-quality resampler (48kHz -> 24kHz with anti-aliasing)\n    this.resampler = new AudioResampler();\n    this.downsampleBuffer = [];\n\n    // Dynamic audio processor (adaptive gain + soft limiter)\n    this.dynamicProcessor = new AudioDynamicProcessor();\n\n    // Frame counter for fade-in (avoid initial click/pop from STFT warmup)\n    // Optimized: Minimal fade-in to preserve first words\n    this.processedFrameCount = 0;\n    this.FADEIN_FRAMES = 1; // Apply fade-in to first frame only (~10ms)\n\n    // CRITICAL: Control flag - only process audio when recording is active\n    this.isRecordingActive = false;\n\n    // Sample counter to track exactly what we process\n    this.totalSamplesReceived = 0;\n    this.totalSamplesProcessed = 0;\n    this.recordingStartSample = null;\n    this.recordingStopSample = null;\n\n    // Get WASM bytes from processor options\n    this.wasmBytes = options?.processorOptions?.wasmBytes;\n    this.modelBytes = options?.processorOptions?.modelBytes;\n\n    // Listen for commands from main thread\n    this.port.onmessage = (event) => {\n      if (event.data === \"start\") {\n        this.isRecordingActive = true;\n        this.totalSamplesReceived = 0;\n        this.totalSamplesProcessed = 0;\n        this.totalOutputSamples = 0;\n        this.firstSampleTime = null;\n        this.recordingStartSample = null;\n        this.recordingStopSample = null;\n      } else if (event.data === \"stop\") {\n        this.recordingStopSample = this.totalSamplesReceived;\n        this.isRecordingActive = false;\n      } else if (event.data === \"flush\") {\n        this.flushBuffers();\n      } else if (event.data?.type === \"cleanup\") {\n        console.log(\"[DeepFilterNet] Cleanup requested\");\n        this.cleanup();\n      }\n    };\n\n    // Initialize WASM module\n    this.initializeWasm();\n  }\n\n  async initializeWasm() {\n    try {\n      // Solo inicializar WASM una vez\n      if (!wasmInitialized && !wasmInitPromise) {\n        // Use WASM bytes from main thread\n        if (!this.wasmBytes) {\n          throw new Error(\"WASM bytes not provided in processorOptions\");\n        }\n\n        const wasmBytes = this.wasmBytes;\n\n        // Initialize WASM\n        wasmInitPromise = init(wasmBytes);\n        await wasmInitPromise;\n\n        wasmInitialized = true;\n      } else if (wasmInitPromise) {\n        // Esperar a que termine la inicializaci\u00F3n en curso\n        await wasmInitPromise;\n      }\n\n      // Cargar modelo desde main thread o usar modelo embebido\n      // Attenuation limit in dB: higher values = more aggressive noise suppression\n      // CRITICAL: Too high removes soft speech, too low doesn't clean noise\n      // Sweet spot: 25-30dB for mixed scenarios (clean audio + noisy audio)\n      // Values: 25dB = gentle, 27dB = light, 30dB = balanced, 32dB = moderate-aggressive\n      // OPTIMIZED: 27dB for preserving clean voice while still removing noise\n      const attenLim = 27; // Gentle cleaning - preserves clean audio better\n\n      // DeepFilterNet WASM analysis:\n      // - Compiled with \"default-model\" feature (has embedded model)\n      // - BUT df_create API doesn't expose a way to use it\n      // - Always calls DfParams::from_bytes(model_bytes)\n      // - Empty array \u2192 panic at flate2/tar extraction\n      // - Invalid tar.gz \u2192 unreachable panic\n      //\n      // Root cause: The tar.gz might be corrupted OR WASM lacks zlib/tar support\n      // Test: Validate gzip magic bytes and try anyway\n\n      if (!this.modelBytes || this.modelBytes.byteLength < 100) {\n        throw new Error(\n          \"DeepFilterNet requires valid model tar.gz - none provided\"\n        );\n      }\n\n      const modelArray = new Uint8Array(this.modelBytes);\n\n      // Validate gzip header (1f 8b)\n      const isGzip = modelArray[0] === 0x1f && modelArray[1] === 0x8b;\n\n      if (!isGzip) {\n        throw new Error(\n          \"Model is not a valid gzip file (missing magic bytes 1f 8b)\"\n        );\n      }\n\n      // Try creating with the provided model\n      this.dfState = df_create(modelArray, attenLim);\n\n      // CRITICAL: Enable post-filter for non-stationary noise (keyboard, clicks, transient sounds)\n      // Beta range: 0.02 = very gentle, 0.04 = gentle, 0.06 = light, 0.08 = moderate\n      // OPTIMIZED: 0.04 for gentle noise removal that preserves clean audio\n      const postFilterBeta = 0.01;\n      df_set_post_filter_beta(this.dfState, postFilterBeta);\n\n      this.frameLength = df_get_frame_length(this.dfState);\n\n      this.initialized = true;\n\n      // CRITICAL: Notify main thread that worklet is ready\n      this.port.postMessage(\"ready\");\n    } catch (error) {\n      this.initialized = false;\n      this.port.postMessage({ type: \"error\", message: error.message });\n    }\n  }\n\n  process(inputs, outputs, parameters) {\n    const input = inputs[0];\n    const output = outputs[0];\n\n    if (!input || !input[0]) {\n      return true;\n    }\n\n    const inputChannel = input[0];\n    const outputChannel = output[0];\n\n    // Count ALL samples (even before recording starts)\n    this.totalSamplesReceived += inputChannel.length;\n\n    // CRITICAL: Only process audio when recording is active\n    // This prevents buffering audio BEFORE user presses \"Start Recording\"\n    if (!this.isRecordingActive) {\n      return true;\n    }\n\n    // Wait until initialized\n    if (!this.initialized || !this.dfState) {\n      return true;\n    }\n\n    // Track first sample time and START of recording\n    if (this.recordingStartSample === null) {\n      this.recordingStartSample =\n        this.totalSamplesReceived - inputChannel.length; // Mark where recording STARTED\n      this.firstSampleTime = currentTime;\n      this.processedFrameCount = 0;\n\n      // Notify main thread that first audio has arrived - safe to start MediaRecorder\n      this.port.postMessage({ type: \"firstAudio\" });\n    }\n\n    // Accumulate current input samples\n    for (let i = 0; i < inputChannel.length; i++) {\n      this.inputBuffer.push(inputChannel[i]);\n    }\n\n    // Process complete frames\n    while (this.inputBuffer.length >= this.frameLength) {\n      // Extract frame\n      const frameArray = this.inputBuffer.splice(0, this.frameLength);\n      const frame = new Float32Array(frameArray);\n\n      // Input validation removed for cleaner logs\n\n      try {\n        // Process with DeepFilterNet\n        const processedFrame = df_process_frame(this.dfState, frame);\n\n        this.processedFrameCount++;\n\n        // Apply fade-in to first few frames to avoid initial click/pop\n        // This is smoother than skipping frames and preserves all audio\n        if (this.processedFrameCount <= this.FADEIN_FRAMES) {\n          const fadeRatio = this.processedFrameCount / this.FADEIN_FRAMES;\n          // Smooth cubic fade-in curve\n          const fadeFactor = fadeRatio * fadeRatio * (3 - 2 * fadeRatio);\n\n          for (let j = 0; j < processedFrame.length; j++) {\n            processedFrame[j] *= fadeFactor;\n          }\n        }\n\n        // Add all processed samples to downsample buffer (no skipping)\n        for (let j = 0; j < processedFrame.length; j++) {\n          this.downsampleBuffer.push(processedFrame[j]);\n        }\n      } catch (error) {\n        // En caso de error, pass through\n        for (let j = 0; j < frame.length; j++) {\n          this.downsampleBuffer.push(frame[j]);\n        }\n      }\n    }\n\n    // High-quality resample 48kHz \u2192 24kHz with anti-aliasing filter\n    // ULTRA LOW LATENCY: Send immediately after each frame is processed\n    // Target: ~10ms @ 24kHz = 240 samples (minimal buffering)\n    const MIN_CHUNK_SIZE_24KHZ = 240; // 10ms @ 24kHz (ultra low latency)\n    const MIN_CHUNK_SIZE_48KHZ = MIN_CHUNK_SIZE_24KHZ * 2; // Need double at 48kHz\n\n    // Check if we have enough samples @ 48kHz to produce output\n    if (this.downsampleBuffer.length >= MIN_CHUNK_SIZE_48KHZ) {\n      // Calculate how many complete chunks we can create (even number for proper decimation)\n      const samplesToProcess = Math.floor(this.downsampleBuffer.length / 2) * 2;\n\n      // Extract samples to process\n      const input48k = new Float32Array(samplesToProcess);\n      for (let i = 0; i < samplesToProcess; i++) {\n        input48k[i] = this.downsampleBuffer[i];\n      }\n\n      // Remove processed samples, keep remainder for next iteration\n      this.downsampleBuffer.splice(0, samplesToProcess);\n\n      // \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n      // STEP 1: High-quality resampling with anti-aliasing FIR filter\n      // \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n      const resampled24k = this.resampler.resample48to24(input48k);\n\n      // \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n      // STEP 2: Adaptive gain normalization + soft limiting\n      // \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n      const { processed, gainApplied, rms, peak, saturated } =\n        this.dynamicProcessor.process(resampled24k);\n\n      // \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n      // STEP 3: Convert Float32 [-1, 1] to PCM16 [-32768, 32767]\n      // \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n      const pcm16 = new Int16Array(processed.length);\n      for (let i = 0; i < processed.length; i++) {\n        // Already normalized and limited, just convert to PCM16\n        const pcmValue = processed[i] * 32768;\n        pcm16[i] = Math.max(-32768, Math.min(32767, Math.round(pcmValue)));\n      }\n\n      // Track output samples\n      this.totalSamplesProcessed += pcm16.length;\n      this.totalOutputSamples += pcm16.length;\n\n      this.port.postMessage(\n        {\n          type: \"pcm16\",\n          data: pcm16.buffer,\n        },\n        [pcm16.buffer]\n      );\n    }\n\n    // Silent output (we send data via postMessage, not audio output)\n    if (outputChannel) {\n      outputChannel.fill(0);\n    }\n\n    return true;\n  }\n\n  flushBuffers() {\n    if (!this.initialized || !this.dfState) {\n      return;\n    }\n\n    // Process remaining samples in inputBuffer\n    // If we have enough for a frame, process it. Otherwise, discard incomplete frame\n    // to avoid adding artificial silence\n    if (this.inputBuffer.length >= this.frameLength) {\n      // Process final complete frame\n      const frameArray = this.inputBuffer.splice(0, this.frameLength);\n      const frame = new Float32Array(frameArray);\n\n      try {\n        const processedFrame = df_process_frame(this.dfState, frame);\n        for (let j = 0; j < processedFrame.length; j++) {\n          this.downsampleBuffer.push(processedFrame[j]);\n        }\n      } catch (error) {\n        // Silent error handling\n      }\n    } else if (this.inputBuffer.length > 0) {\n      // Clear incomplete frame to avoid artificial duration extension\n      this.inputBuffer = [];\n    }\n\n    // Process remaining samples in downsampleBuffer\n    if (this.downsampleBuffer.length > 0) {\n      // Process whatever we have (even if less than MIN_CHUNK_SIZE)\n      const samplesToProcess = Math.floor(this.downsampleBuffer.length / 2) * 2;\n\n      if (samplesToProcess >= 2) {\n        const input48k = new Float32Array(samplesToProcess);\n        for (let i = 0; i < samplesToProcess; i++) {\n          input48k[i] = this.downsampleBuffer[i];\n        }\n        this.downsampleBuffer.splice(0, samplesToProcess);\n\n        const resampled24k = this.resampler.resample48to24(input48k);\n        const { processed } = this.dynamicProcessor.process(resampled24k);\n\n        const pcm16 = new Int16Array(processed.length);\n        for (let i = 0; i < processed.length; i++) {\n          const pcmValue = processed[i] * 32768;\n          pcm16[i] = Math.max(-32768, Math.min(32767, Math.round(pcmValue)));\n        }\n\n        this.port.postMessage(\n          {\n            type: \"pcm16\",\n            data: pcm16.buffer,\n          },\n          [pcm16.buffer]\n        );\n      }\n    }\n  }\n\n  cleanup() {\n    console.log(\"[DeepFilterNet] Cleaning up resources...\");\n    \n    // Clean DeepFilterNet state\n    if (this.df && dfWasm) {\n      try {\n        dfWasm.df_free(this.df);\n        console.log(\"[DeepFilterNet] \u2705 DF state freed\");\n      } catch (e) {\n        console.warn(\"[DeepFilterNet] Error freeing DF state:\", e);\n      }\n      this.df = null;\n    }\n    \n    // Clear buffers\n    this.inputBuffer = [];\n    this.downsampleBuffer = [];\n    this.outputBuffer = [];\n    \n    this.initialized = false;\n    console.log(\"[DeepFilterNet] \u2705 Cleanup complete\");\n  }\n}\n\nregisterProcessor(\"deepfilter-processor\", DeepFilterProcessor);\n"],
  "mappings": "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",
  "names": ["module", "module"]
}
